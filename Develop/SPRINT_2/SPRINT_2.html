<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3, h4 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 120%;
}
h4 {
    background-color: #99ffcc;
    font-size: 90%;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<head>
   
<title>FinalTask-ISS-2020</title></head>
    
<body>
<div id="top">
<h1>FinalTask-ISS-2020<font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
The <em>supervisor</em> of a waiting room (<em>wroom</em>) of a large train station intends to promote automatic collection of the rubbish, by means of ddr robots.
To this end, some specialized robot (<em>detector</em>) periodically explores the surface of the <em>wroom</em> in order to collect objects 
made of recyclable material, in particular bottles made of <i>plastic</i> .
 
<h2>Requirements</h2>
<div class="req">
Design and build the software to put on board of the <em>plasticBox</em> and of the <em>detector</em>. The system
must be able to accept the following commands sent by the <i>smart-phone</i> of the <em>supervisor</em>:

<ul>
<li><bc>explore</bc>: the <em>detector</em> must execute the task <i>Explore the room</i>.</li>
<!-- <li><em>empty</em>:   the <em>detector</em> must execute in autonomous way  the <i>Empty the detectorBox</i> task.</li> -->
<li><bc>suspend</bc>:   the <em>detector</em> must execute the task <i>Go to home</i>. </li>
<li><bc>terminate</bc>:  the <em>detector</em> must execute the task <i>Terminate the work</i>.</li>

</ul>
</div>

<h2>Requirement analysis</h2>

<h3>Functional TestPlan</h3>
<h4>Explore</h4>
After discussing with the client, the objective of this test plan is to verify that the detector is able to explore the entirety of the room, as a consequence, the entire map of the room.<br/>
<ul>
<li>At the start of the test the detector is situated in the top-left corner of the room.</li>
<li>At the end of the test the detector must have went through every cell of the map.</li>
</ul>
<h4>Suspend</h4>
After discussing with the client, the objective of this test plan is to verify that the detector returns home after a suspend command.<br/>
<ul>
<li>At the start of the test the detector is situated in the top-left corner of the room.</li>
<li>At the end of the test the detector must have returned at the start.</li>
</ul>
<h4>Terminate</h4>
After discussing with the client, the objective of this test plan is to verify that the detector empties the detectorBox and returns home after a terminate command.<br/>
<ul>
<li>At the start of the test the detector is situated in the top-left corner of the room.</li>
<li>At the end of the test the detector must have collected some bottles, emptied them in the plasticBox and returned at the start.</li>
</ul>

<h2>Problem analysis</h2>

<h3>The wroom problematics</h3>
<h4>The planner</h4>
The softwarehouse is already provided of a tool called planner.<br/>
This tool is able to produce a map and to make plans on it.<br/>
Every time the robot makes a move, the plan is calculated and the map is produced with every step.<br/>
If the robot encounters an obstacle, the map must be updated with the obstacle position and the plan must be recalculated.


<h4>The map</h4>
The map produced its based on the robot measure: every robot step its a new cell on the map, this cell is filled with a 1,0 or X depending on the situation.<br/>
If the robot has explored the cell the map shows a 1, otherwise a 0 if its not yet explored or an X if its an obstacle.<br/>
This process of mapping could be automatized if the room and the objects in it are static, otherwise the process must be executed every time the detector explores the room.
<h4>The room problematic final take</h4>
Having at disposal this tool, it doesn't matter if the room has objects or not, or if they are moving or not, the map can be calculated every time the robot explores it.

<h4>The movement problematic</h4>
The robot can move forward, backward and can turn left or right by 90 degrees, morover the robot exploration always start with the robot in coordinates (0,0) facing south.
<h4>The obstacle problematic</h4>
The robot is able to move, as a consequence, a new problematic arise: the robot, when moving forward, should be able to stop in the presence of an obstacle.<br/>
The stop should be forced below a certain threshold distance from the obstacle.<br/>
This is already possible and already implemented inside the basicrobot.qak.<br/>
When using a real robot a sensor is needed to notify the basicrobot of an obstacle.<br/>
This was already discussed in the basicrobot development, refer to it for more informations.

<h3>The plastic box problematic (Maicol)</h3>
How is the plasticBox supposed to know how many bottles has collected at a given time?<br/>
Considering that the content of the detectorBox is released inside the plasticBox, this problematic could be solved in different ways:<br/>
<ul>
	<li>The plasticBox is equipped with a sensor that allows to count the number of bottles that are being discharged, in this case the detector just check the resource to see if he can discharge.</li>
	<li>The plasticBox interacts directly with the detector and its notified of the number of bottles that the detector is discharging.</li>
	<li>The plasticBox and the detector interacts only via CoAP updating resources.</li>
</ul>
As an analyst, the choice that better solves our case, is that the detector, after checking that 
the plasticBox can receive the content of the detectorBox, notifies the plasticBox of the bottles that it is discharging.<br/>
This check is possible via the CoAP resources updated by the plasticBox and the detectorBox.<br/>
This choice was taken because the company doesn't possess a sensor that allows to count bottles, and the client is cheap.

<h3>Finding the plastic box problematic</h3>
When the detector has to empty the detectorBox, it could happen that the plasticBox hasn't already been discovered.<br/>
To prevent this kind of situation, it is assumed that the plasticBox is always situated in a known place of the room.<br/>
In particular is situated at coordinates (0,0).

<h3>Functional Architecture</h3>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The Detector (Christian/Bondi)</h4>
<pre>
QActor detector context ctxWroom{
	State s0 initial{
 		run kotlincode.coapSupport.observeCommands(myself)
	}
	Goto work
	
	State work{
		["goToHome = false"]
		run itunibo.planner.plannerUtil.showMap()
	} 
	Transition t0 
		whenMsg explore -> startExplore
		whenMsg suspend -> goHome
		whenMsg terminate -> terminateTask
  	
  	State startExplore{
  		printCurrentMessage
  		run itunibo.planner.plannerUtil.initAI()
		["radius = 0"]
  	}
  	Goto exploreNextRadius
  	
  	State exploreNextRadius {
  		println("")
  		println("------------")
  		println("exploreNextRadius: $radius")
		["
			radius = radius + 1
			radiusFinished = false
			exploreY = radius
			exploreX = 0
			exploringHorizontal = true
		"]
	}
	Goto doExplore if "(!itunibo.planner.plannerUtil.isFullyExplored() && !goToHome)" else gotoUnexplored
  	
  	State gotoUnexplored {
  		println("gotoUnexplored")
  		["	radiusFinished = true
			unexploredPosition = itunibo.planner.plannerUtil.getFirstNonExploredPosition()
		"]
  		if "unexploredPosition != null && goToHome" {
  			run itunibo.planner.plannerUtil.setGoal("${unexploredPosition!!.first}","${unexploredPosition!!.second}")
			run itunibo.planner.plannerUtil.doPlan()
			
  		} else {
  			["goToHome = true"]
  		}
  	}
  	Goto doPlannedMoves if "(unexploredPosition != null)" else executeEmptyTheDetectorBox

	State executeEmptyTheDetectorBox {
  		run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
  		["val BottlesInDetector = Result.get(1)"]
  		if "BottlesInDetector!!.compareTo(0) > 0" {
			run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
			["val bottlesInPlasticBox = Result.get(1) !!
			  val NPB = Result.get(2)
			  val totalBottles = bottlesInPlasticBox.plus(BottlesInDetector !!)"]
			if "compareValues(NPB, totalBottles) >= 0" {
				["emptyTheDetectorBox = true"]
			} else {
				["goToHome = false"]
			}
  		}
	}
	Goto goHome if "goToHome" else waitForCommand
	
	State terminateTask {
		printCurrentMessage
		onMsg( terminate : terminate( X )) {
			["goToHome = true"]
			run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
  			["val BottlesInDetector = Result.get(1)"]
  			println("Terminate Task: $BottlesInDetector and result = $Result")
			if "BottlesInDetector!!.compareTo(0) > 0" {
				run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
				["val bottlesInPlasticBox = Result.get(1) !!
			  	val NPB = Result.get(2)
			  	val totalBottles = bottlesInPlasticBox.plus(BottlesInDetector !!)"]
			  	println("npb = $NPB total=   $totalBottles")
				if "compareValues(NPB, totalBottles) >= 0" {
					["emptyTheDetectorBox = true"]
					["robotWasExploring = false"]
				}  else {
					run kotlincode.coapSupport.updateResource(myself, "wroom/robotCommand", "waiting")
				}
  			}
  			
 		}
	}
	Goto goHome

	State waitForCommand {
		run kotlincode.coapSupport.updateResource(myself, "wroom/robotCommand", "waiting")
	}
	Transition t0
		whenMsg suspend -> goHome
		whenMsg terminate -> terminateTask
		whenMsg explore -> doPlannedMoves

	State goHome {
		run itunibo.planner.plannerUtil.setGoal("0", "0")
		run itunibo.planner.plannerUtil.doPlan()
	} 
	Goto executeHomeMove
 	 
 	State executeHomeMove {
 		printCurrentMessage
 		["	var PosX = "] run itunibo.planner.plannerUtil.getPosX()
		["	var PosY = "] run itunibo.planner.plannerUtil.getPosY()
		["	var Dir = "] run itunibo.planner.plannerUtil.getDirection()
		run kotlincode.coapSupport.updateDetectorPosition("($PosX, $PosY)", "$Dir", "Moving")
		["var Map = "] run itunibo.planner.plannerUtil.getMap()
		run kotlincode.coapSupport.updateResource(myself, "wroom/roomMap", "$Map")
 		
 		
 		if "(itunibo.planner.plannerUtil.isRobotHome())" {
 			if "emptyTheDetectorBox" {
 				forward detector -m detectorMustEmpty : detectorMustEmpty( OK )
 			} else {
 				forward detector -m backHome : backHome( OK )
 			}
 			run kotlincode.coapSupport.updateResource(myself, "wroom/robotCommand", "home")
 		}
		else {
	 		delay 500
			["var CmdPayload = itunibo.planner.plannerUtil.getNextPlannedMove()"]
			run itunibo.planner.plannerUtil.doMove(CmdPayload)
			if "CmdPayload == \"w\"" {
				//TODO Step		
				request steprobot -m onestep : onestep($StepDuration)
			} 
			if "CmdPayload == \"a\"" {
				forward basicrobot -m cmd : cmd( l )	
				forward detector -m moveOk : moveOk(OK)
			} 
			if "CmdPayload == \"d\"" {
				forward basicrobot -m cmd : cmd( r )	
				forward detector -m moveOk : moveOk(OK)
			}
		}
 	}
	Transition t1 
		whenMsg backHome -> work
		whenMsg moveOk -> executeHomeMove
		whenReply stepdone -> executeHomeMove
		whenMsg detectorMustEmpty -> executeBottlesTransfer
		whenMsg suspend -> goHome
		whenMsg terminate -> terminateTask
	
	State executeBottlesTransfer {
		println("executeEmptyDetectorBox")
		run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
		["val BottlesInDetector = Result.get(1) !!"]
		run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
		["val bottlesInPlasticBox = Result.get(1) !!
		  val NPB = Result.get(2)
		  val totalBottles = bottlesInPlasticBox.plus(BottlesInDetector !!)
		"]
		if "compareValues(NPB, totalBottles) >= 0" {
			forward detectorbox -m emptyBottleResource : emptyBottleResource(0)
			forward plasticbox -m collect : collect($BottlesInDetector)
			["emptyTheDetectorBox = false"]
			["goToHome = false"]
			println("ROBOT EXPLORING?: $robotWasExploring")
			if "robotWasExploring" {
				["robotWasExploring = false"]
				run itunibo.planner.plannerUtil.setGoal("$beforeEmptyPos_x","$beforeEmptyPos_y")
				run itunibo.planner.plannerUtil.doPlan()
				forward detector -m moveOk:moveOk(OK)
			} else {
				forward detector -m backHome:backHome(OK)
				run kotlincode.coapSupport.updateResource(myself, "wroom/robotCommand", "home")
			}
		}
	}
	Transition t0
		whenMsg moveOk -> doPlannedMoves
		whenMsg backHome -> work
	
	State doExplore {
		["if (exploreY < 0) { radiusFinished = true }"]
		if "(!radiusFinished)" {
			println("")
			println("doExplore: currentMap:")
			run itunibo.planner.plannerUtil.showMap()
			
			//UPDATE RESOURCE
			["var Map = "] run itunibo.planner.plannerUtil.getMap()
			run kotlincode.coapSupport.updateResource(myself, "wroom/roomMap", "$Map")
			
			println("doExplore goal: ($exploreX,$exploreY)")
			run itunibo.planner.plannerUtil.setGoal("$exploreX","$exploreY")
			run itunibo.planner.plannerUtil.doPlan()
			["
				if (exploringHorizontal) {
					if (exploreX < radius) { exploreX = exploreX + 1 }
					else { 
						exploringHorizontal = false 
						exploreY = exploreY - 1
					}
				} else {
					exploreY = exploreY - 1
				}
			"]
		}
	}
	Goto doPlannedMoves if "(!radiusFinished && !itunibo.planner.plannerUtil.isFullyExplored())" else exploreNextRadius
	
	State doPlannedMoves {
		//UPDATE RESOURCES
		["	var PosX = "] run itunibo.planner.plannerUtil.getPosX()
		["	var PosY = "] run itunibo.planner.plannerUtil.getPosY()
		["	var Dir = "] run itunibo.planner.plannerUtil.getDirection()
		run kotlincode.coapSupport.updateDetectorPosition("($PosX, $PosY)", "$Dir", "Moving")
		["var Map = "] run itunibo.planner.plannerUtil.getMap()
		run kotlincode.coapSupport.updateResource(myself, "wroom/roomMap", "$Map")
		
	} 
	Goto doMove if "(itunibo.planner.plannerUtil.hasPlannedMoves())" else doExplore
	
	State doMove {
		delay 500
		["var CmdPayload = itunibo.planner.plannerUtil.getNextPlannedMove()"]
		
		println("-----")
		println("doMove: move is $CmdPayload")
		println("-----")
		run itunibo.planner.plannerUtil.doMove(CmdPayload)
		if "CmdPayload == \"w\"" {
			//TODO Step		
			request steprobot -m onestep : onestep($StepDuration)
		} 
		if "CmdPayload == \"a\"" {
			forward basicrobot -m cmd : cmd( l )	
			forward detector -m moveOk : moveOk(OK)
		} 
		if "CmdPayload == \"d\"" {
			forward basicrobot -m cmd : cmd( r )	
			forward detector -m moveOk : moveOk(OK)
		}
		
	}
	Transition t1 
		whenMsg moveOk -> doPlannedMoves
		whenReply stepdone -> doPlannedMoves
		whenReply stepfail -> onStepFail
		whenMsg suspend -> goHome
		whenMsg terminate -> terminateTask

	
	State onStepFail {
		onMsg( stepfail : stepfail( DURATION, CAUSE )) {		
			["IsBottle = payloadArg(1).startsWith(\"bottle\")"]
 			if "IsBottle" {  //remove the bottle
 				["val StepTimeLeft = StepDuration - payloadArg(0).toLong()"]
 				forward basicrobot -m cmd : cmd( $payloadArg(1) )
 				delay 100  //give time to remove  the object payloadArg(1) TODO: request?
 				forward basicrobot -m cmd : cmd(h)
 				forward detectorbox -m updateBottle : updateBottle(1)
	 			request steprobot -m onestep: onestep($StepTimeLeft)
 				println("onStepFail: bottle, step of duration $StepTimeLeft")
    		} else{
 				forward basicrobot -m cmd : cmd(h)		
				run itunibo.planner.plannerUtil.setRobotPositionAsObstacle()			
	 			run itunibo.planner.plannerUtil.stepBack()
	 			println("onStepFail: stepbackwards of duration ${payloadArg(0)}")
	 			request steprobot -m onestepbackwards : onestepbackwards($payloadArg(0))	
 			}
		}
	}
	Transition t1 whenReply stepdone -> afterStepFail
  	
  	
	State afterStepFail {
		if "IsBottle" {
			run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
			["val BottlesInDetector = Result.get(1) !!
			  val NDB = Result.get(2)"]
			if "(compareValues(NDB, BottlesInDetector) == 0)" {
				run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
				["val bottlesInPlasticBox = Result.get(1) !!
				  val NPB = Result.get(2)
				  val totalBottles = bottlesInPlasticBox.plus(BottlesInDetector !!)
				"]
				if "compareValues(NPB, totalBottles) >= 0" {
					["beforeEmptyPos_x = "] run itunibo.planner.plannerUtil.getPosX()
					["beforeEmptyPos_y = "] run itunibo.planner.plannerUtil.getPosY()
					["goToHome = true
					  emptyTheDetectorBox = true
					  robotWasExploring = true"]
					forward detector -m detectorMustEmpty : detectorMustEmpty(OK)
				} else {
					run kotlincode.coapSupport.updateResource(myself, "wroom/robotCommand", "waiting")
					forward detector -m detectorCantEmpty : detectorCantEmpty(detectorCantEmpty)
				}
			} else {
				forward detector -m moveOk : moveOk(OK)
			}
		} else {
			forward detector -m obstacleFound : obstacleFound(X)
		}
 	}
 	Transition t1
	 	whenMsg moveOk -> doPlannedMoves
	 	whenMsg obstacleFound -> doExplore
		whenMsg detectorMustEmpty -> goHome
		whenMsg detectorCantEmpty -> waitForCommand
		whenMsg suspend -> goHome
		whenMsg terminate -> terminateTask

}
</pre>
</td>
<td>
<h4>Steprobot (Christian)</h4>
<pre>
QActor steprobot context ctxWroom {
	State s0 initial{
 		println("steprobot starts")	
	}
	Goto activateResource 
	
	State activateResource{  
	}
	Goto work 
	
	State work{	} 
	Transition s0 
 			whenMsg cmd        -> handleCmd
 			whenRequest onestep -> doStep
			whenRequest onestepbackwards -> doStepBackwards
 
	State handleCmd {
		onMsg( cmd : cmd(X) ){ 
			["var Move = payloadArg(0)"]
			forward basicrobot -m cmd : cmd( $Move )
		}
	} Goto work 
  
	State doStep{ 
		onMsg( onestep : onestep( T ) ){
			forward basicrobot -m cmd : cmd( w )  //ATTEMPT TO MOVE ...
			["StepTime = payloadArg(0).toLong() 
 			  startTimer()"]	//REQUIREMENT req-onestep-time
			println("steprobot | doStep StepTime =$StepTime ")
		}  
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone	  
 	    whenEvent virtualobstacle -> stepFailVirtual 
 	
 	State doStepBackwards {
 		onMsg ( onestepbackwards: onestepbackwards(T) ) {
 			["StepBackwardsTime = payloadArg(0).toLong() - 30
			  startTimer()"]
			  println("steprobot | doStepBackwards StepBackwardsTime =$StepBackwardsTime")
		  	forward basicrobot -m cmd : cmd ( s )
 		}
 	}  
	Transition t0 
		whenTimeVar StepBackwardsTime  -> stepBackwardsDone
		
	State stepBackwardsDone {
		forward basicrobot -m cmd : cmd( h )
		replyTo onestepbackwards with stepdone : stepdone(ok)
	}
	Goto work
 	
	State stepDone{  //REQUIREMENT  req-onestep-info
		forward basicrobot -m cmd : cmd( h ) 
 		replyTo onestep with stepdone : stepdone(ok)
  	}
	Goto work

	State stepFailVirtual{ //REQUIREMENT req-onestep-time, req-onestep-info
		[" Duration=getDuration()
		  TimeToEndStep = StepTime - Duration
		"]
		
		forward basicrobot -m cmd : cmd( h )
		onMsg( virtualobstacle : virtualobstacle( OBJNAME )) {
			replyTo onestep with stepfail : stepfail($Duration, $payloadArg(0))
		} 
   	}
	Goto work 
  
}
</pre>
</td>
</tr>
</tbody></table>


<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The plasticBox (Maicol)</h4>
<pre>
QActor plasticbox context ctxWroom{
["
	var Result:HashMap<Int,Int> = HashMap<Int,Int>()
	var NPB:Int = 0
"]
	State s0 initial{
		run kotlincode.coapSupport.init("coap://localhost:5683")  //TO CHANGE!!!
		["NPB = plasticBox.plasticBoxSupport.NPB"]
		run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "NPB=$NPB")
		run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
		["val Bottles = Result.get(1)
		  val npb = Result.get(2)"]
	}
	Goto work
	
	State work {}
	Transition t0
		whenMsg collect -> doCollect
		whenMsg empty -> emptyTheBox
	
	State doCollect{
		onMsg(collect : collect(X)) {
			["var Bottles = payloadArg(0)"]
			run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "$Bottles")
		}
	}
	Goto work

	State emptyTheBox {
		onMsg(empty : empty(X)) {
			["var Bottles = payloadArg(0)"]
			run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "0")
		}
	}
	Goto work
}
</pre>
</td>
<td>
<h4>The resource of the plasticBox (Maicol)</h4>
<pre>
class resPlasticBox( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var bottles = 0
	var NPB = 0 
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$bottles,$NPB" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetBottles() }
	 		else -> {
				if (msg.contains("NPB")) {
					val NPBValue = msg.substring(4)
					setNPB(NPBValue)
				} else {
					updateBottles(msg)
				}
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun updateBottles(msg:String){
		var value = msg.toIntOrNull()
		if (value != null) {
			bottles = bottles+value
		}
	}
	fun resetBottles(){
		bottles = 0
	}
	fun setNPB(NPBValue:String){
		var value = NPBValue.toIntOrNull()
		if (value != null){
			NPB = value
		}
	}
}
</pre>
</td>
</tr>
</tbody></table>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The detectorBox (Maicol)</h4>
<pre>
QActor detectorbox context ctxWroom{
["
	var Result:HashMap<Int,Int> = HashMap<Int,Int>()
	var NDB:Int = 0
"]
 	State s0 initial{
 		run kotlincode.coapSupport.init("coap://localhost:5683")
 		["NDB = detector.detectorSupport.NDB"]
 		run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "NDB=$NDB")
 		run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
		["val Bottles = Result.get(1)
		  val ndb = Result.get(2)"]
 	}
	Goto work 
	
	State work{}
	Transition t0
		whenMsg updateBottle -> updateBottleResource
		whenMsg emptyBottleResource -> emptyBottleResource
	
  	State updateBottleResource{
		onMsg( updateBottle : updateBottle(X)){
			run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "1")
		}   
	}
  	Goto work 
	
	State emptyBottleResource {
		onMsg(emptyBottleResource : emptyBottleResource(X)){
			run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "0")
		}
	}
	Goto work
 }
</pre>
</td>
<td>
<h4>The resource of the detectorBox (Maicol)</h4>
<pre>
class resDetectorBox( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var bottles = 0
	var NDB = 0
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$bottles, $NDB" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetBottles() }
	 		else -> {
				if (msg.contains("NDB")) {
					val NDBValue = msg.substring(4)
					setNDB(NDBValue)
				} else {
					updateBottles()
				}
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun updateBottles(){
		bottles = bottles+1
	}
	fun resetBottles(){
		bottles = 0
	}
	fun setNDB(NDBValue:String){
		var value = NDBValue.toIntOrNull()
		if (value != null){
			NDB = value
		}
	}
}
</pre>
</td>
</tr>
</tbody></table>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>ResDetectorPosition (Maicol)</h4>
<pre>
class resDetectorPosition( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var pos        = "(0,0)"
	var direction  = "SUD"
	var moving     = "idle"
	init{
		setObservable(true)		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "pos$pos,dir($direction),moving$moving" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" -> resetDetector()
 			else -> {
				var splitted = msg.split(".")
				pos = splitted[0]
				direction = splitted[1]
				moving = splitted[2]
			}
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun resetDetector(){
		pos = "(0,0)"
		direction = "SUD"
		moving = "false"
	}
}
</pre>
</td>
<td>
<h4>ResRoomMap (Maicol)</h4>
<pre>
class resRoomMap( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var roomMap:String = ""
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$roomMap ")  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetMap() }
	 		else -> {
				roomMap = msg
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun resetMap(){
		roomMap = ""
	}
}
</pre>
</td>
</tr>
</tbody></table>


<h3>The ProductBacklog</h3>
<strong>TASK EXPLORE THE ROOM</strong>: implement this task.<br/>
<strong>TASK EMPTY THE DETECTORBOX</strong>: implement this task.<br/>
<strong>PLASTICBOX</strong>: implement the plasticBox qactor.<br/>
<strong>FRONTEND</strong>: add 2 new buttons for suspend and terminate.<br/>
<strong>TASK GO TO HOME</strong>: implement this task.<br/>
<strong>TASK TERMINATE THE WORK</strong>: implement this task.<br/>
<strong>RESOURCES</strong>: implement the new resources. <br/>
<strong>TESTPLANS</strong>: prepare functional test plans.<br/>

<h3>The Effort/Resources</h3>
<strong>PLASTICBOX</strong>: The implementations of the plasticBox requires a .QAK and a resource. (1 hour)<br/>
<strong>FRONTEND</strong>: Add 2 buttons. (5 minute)<br/>
<strong>RESOURCES</strong>: Estimated 1 man hour.<br/>
<strong>DETECTOR WITH TASKS</strong>: Estimated 1 week because it comprehends the planner development.<br/>
<strong>TESTPLANS</strong>: Estimated 3 man hour.

<h2>Test plans</h2> 
<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>Explore</h4>
<pre>
@Test
	public void sprint_2_Test() {
		CoapClient detectorBoxClient = new CoapClient(detectorBoxRes);
		CoapClient plasticBoxClient = new CoapClient(plasticBoxRes);
		CoapClient roomMapClient = new CoapClient(roomMapRes);
		
		assertTrue("detectorbox is empty?", detectorBoxClient.get().getResponseText().substring(0, 1).equals("0"));
		System.out.println("MAP:"+roomMapClient.get().getResponseText());
		assertTrue("map is correctly initialized?", roomMapClient.get().getResponseText().equals(MAP_START));

		try {
			MqttClient publisherClient = new MqttClient(broker, clientId, persistence);
			MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            publisherClient.connect(connOpts);
            assertTrue("client is connected?", publisherClient.isConnected());
            MqttMessage message = new MqttMessage(msgContent.getBytes());
            message.setQos(qos);
            publisherClient.publish(detectorTopic, message);
            publisherClient.disconnect();
            publisherClient.close();
		} catch (MqttException me) {
			System.out.println("reason "+me.getReasonCode());
            System.out.println("msg "+me.getMessage());
            System.out.println("loc "+me.getLocalizedMessage());
            System.out.println("cause "+me.getCause());
            System.out.println("excep "+me);
            me.printStackTrace();
		}

		try {
			Thread.sleep(2 *   // minutes to sleep
		             60 *   // seconds to a minute
		             1000); // milliseconds to a second
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		String map = roomMapClient.get().getResponseText();

		assertTrue("is the map right?", RoomMap.fromString(map).isFullyExplored());
		assertTrue("bottle emptied?", detectorBoxClient.get().getResponseText().substring(0, 1).equals("0"));
		assertTrue("bottle collected?", plasticBoxClient.get().getResponseText().substring(0, 1).equals(BOTTLES));
		
	}
</pre>
</td>
<td>
<h4>Suspend</h4>
<pre>
@Test
	public void sprint_2_Test() {
		
		CoapClient detectorPosition = new CoapClient(resDetectorPosition);
		
		try {
			MqttClient publisherClient = new MqttClient(broker, clientId, persistence);
			MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            publisherClient.connect(connOpts);
            assertTrue("client is connected?", publisherClient.isConnected());
            MqttMessage message = new MqttMessage(msgContentExplore.getBytes());
            message.setQos(qos);
            publisherClient.publish(detectorTopic, message);
            
            Thread.sleep(  // minutes to sleep
		             10 *   // seconds to a minute
		             1000); // milliseconds to a second
            
            
            String v = "state("+detectorPosition.get().getResponseText()+")";
            
    		String coordinates = ( (Struct) Term.createTerm(v)).getArg(0).toString();
    		String idle = ( (Struct) Term.createTerm(v)).getArg(2).toString();
    		System.out.println(v+" "+coordinates+" "+idle);
    		
    		assertTrue("is the detector exploring?", !coordinates.equals("pos(0,0)"));
    		
            MqttMessage messageSuspend = new MqttMessage(msgContentSuspend.getBytes());
            messageSuspend.setQos(qos);
            publisherClient.publish(detectorTopic, messageSuspend);
            publisherClient.disconnect();
            publisherClient.close();
		} catch (MqttException | InterruptedException me) {
            me.printStackTrace();
		}
		
		try {
			Thread.sleep(  // minutes to sleep
			             20 *   // seconds to a minute
			             1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		String v = "state("+detectorPosition.get().getResponseText()+")";
        
		String coordinates = ( (Struct) Term.createTerm(v)).getArg(0).toString();
		System.out.println("coord: "+coordinates);
		assertTrue("is the detector back at home?", coordinates.equals("pos(0,0)"));	
	}
</pre>
</td>
</tr>
</tbody></table> 

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>Terminate</h4>
<pre>
@Test
	public void sprint_1_Test() {
		
		CoapClient detectorPosition = new CoapClient(resDetectorPosition);
		CoapClient detectorBox = new CoapClient(resDetectorBox);
		CoapClient plasticBox = new CoapClient(resPlasticBox);
		
		try {
			MqttClient publisherClient = new MqttClient(broker, clientId, persistence);
			MqttConnectOptions connOpts = new MqttConnectOptions();
            connOpts.setCleanSession(true);
            publisherClient.connect(connOpts);
            assertTrue("client is connected?", publisherClient.isConnected());
            MqttMessage message = new MqttMessage(msgContentExplore.getBytes());
            message.setQos(qos);
            publisherClient.publish(detectorTopic, message);
            
            String boxContent =  detectorBox.get().getResponseText().substring(0, 1);
            while (boxContent.equals("0")) {
            	boxContent =  detectorBox.get().getResponseText().substring(0, 1);
            	Thread.sleep(500);
            }
            Thread.sleep(100);
            
            System.out.println("box: "+detectorBox.get().getResponseText().substring(0, 1));
            assertTrue("detectorbox is not empty?", !detectorBox.get().getResponseText().substring(0, 1).equals("0"));
            assertTrue("plasticbox is empty?", plasticBox.get().getResponseText().substring(0, 1).equals("0"));
            
    		String v = "state("+detectorPosition.get().getResponseText()+")";
            
    		String coordinates = ( (Struct) Term.createTerm(v)).getArg(0).toString();
    		
    		assertTrue("is the detector exploring?", !coordinates.equals("pos(0,0)"));
    		
            MqttMessage messageTerminate = new MqttMessage(msgContentTerminate.getBytes());
            messageTerminate.setQos(qos);
            publisherClient.publish(detectorTopic, messageTerminate);
            publisherClient.disconnect();
            publisherClient.close();
		} catch (MqttException | InterruptedException me) {
            me.printStackTrace();
		}
		
		try {
			Thread.sleep(  // minutes to sleep
			             20 *   // seconds to a minute
			             1000);
			Thread.sleep(200);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		String v = "state("+detectorPosition.get().getResponseText()+")";
        
		String coordinates = ( (Struct) Term.createTerm(v)).getArg(0).toString();
		System.out.println("box: "+detectorBox.get().getResponseText().substring(0, 1));
		
		assertTrue("is the detector back at home?", coordinates.equals("pos(0,0)"));
		assertTrue("is the detectorBox empty?", detectorBox.get().getResponseText().substring(0, 1).equals("0"));
		assertTrue("is the plasticBox not empty?", !plasticBox.get().getResponseText().substring(0, 1).equals("0"));
		
	}
</pre>
</tr>
</tbody></table> 




<h2>Project</h2> 
<h3>Magic Numbers and the need of new adapters (Maicol)</h3>
The detectorBox needs a constant value to be started: NDB.<br/>
The plasticBox needs a constant value to be started: NPB.<br/>
These values are related to the capacity of the bins that these actors represent.<br/>
The problem is that if the bin is changed to another one, the main code must be modified to set the correct values.<br/>
This is not an appropriate behaviour, as a consequence, a new adapter is created for each Box.<br/>
The job of the adapters is to read a configuration file that contains all the info that are required to initialize the actors and create a support that store these informations.<br/>
This change will also be relevant for future upgrades if more informations are needed to be configured.<br/><br/>
<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The detectorAdapter (Maicol)</h4>
<pre>
class detectorAdapter( name : String ) : ActorBasic( name ){  
    init{
		println("	--- detectorAdapter | started")
		val sol1 = pengine.solve( "consult('detectorConfig.pl')." )
		if( ! sol1.isSuccess() ){
			println("	--- detectorAdapter | ERROR in detectorConfig.pl")
		}else{
	 		val sol2 = pengine.solve( "detectorBox(NDB)." )
	 		if( sol2.isSuccess() ){
				val NDB =  sol2.getVarValue("NDB").toString()
				println("	--- detectorAdapter | USING NDB: $NDB")
				val NDB_Int = NDB.toInt()
				detector.detectorSupport.create( NDB_Int )   
			}
		}		  		      
    }
    override suspend fun actorBody(msg : ApplMessage){
        //println("	--- robotAdapterQaStream | received  msg= $msg "  ) //msg.msgContent()=cmd(X)
		sysUtil.traceprintln(" $tt $name | received  $msg "  ) //msg.msgContent()=cmd(X)
    }
}
</pre>
</td>
<td>
<h4>The detectorSupport (Maicol)</h4>
<pre>
object detectorSupport{
	var NDB  :  Int = 0
	
	fun create( ndb:Int ){
		NDB = ndb
	}
}
</pre>
</td>
</tr>
</tbody></table> 

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The plasticBoxAdapter (Maicol)</h4>
<pre>
class plasticBoxAdapter( name : String ) : ActorBasic( name ){  
    init{
		println("	--- plasticBoxAdapter | started")
		val sol1 = pengine.solve( "consult('plasticBoxConfig.pl')." )
		if( ! sol1.isSuccess() ){
			println("	--- plasticBoxAdapter | ERROR in plasticBoxConfig.pl")
		}else{
	 		val sol2 = pengine.solve( "plasticBox(NPB)." )
	 		if( sol2.isSuccess() ){
				val NPB =  sol2.getVarValue("NPB").toString()
				println("	--- plasticBoxAdapter | USING NPB: $NPB")
				val NPB_Int = NPB.toInt()
				plasticBox.plasticBoxSupport.create( NPB_Int )   
			}
		}		  		      
    }
 
    override suspend fun actorBody(msg : ApplMessage){
        //println("	--- robotAdapterQaStream | received  msg= $msg "  ) //msg.msgContent()=cmd(X)
		sysUtil.traceprintln(" $tt $name | received  $msg "  ) //msg.msgContent()=cmd(X)
    }
}
</pre>
</td>
<td>
<h4>The plasticBoxSupport (Maicol)</h4>
<pre>
object plasticBoxSupport{
	var NPB  :  Int = 0
	
	fun create( npb:Int ){
		NPB = npb
	}
}
</pre>
</td>
</tr>
</tbody></table> 
<h3>From MQTT to CoAP (Christian)</h3>
To exclude any knowledge of the implementation detail to the front-end, the front-end will send the required command to the detector via CoAP resource instead of mqtt.
<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The Detector as a resource observer. (Christian)</h4>
<pre>
run kotlincode.coapSupport.observeCommands(myself)
</pre>
</td>
<td>
<h4>The resource observer (Christian)</h4>
<pre>
fun observeCommands(actor: ActorBasic) {
		setClientForPath("wroom/robotCommand")
		val relation = client.observe(ForwardCommandToActor(actor))
}

class ForwardCommandToActor(actor: ActorBasic): CoapHandler {
	
	var actor: ActorBasic
	var previous: String? = null
	init {
		this.actor = actor
	}
	override fun onLoad(response: CoapResponse) {
		val content = response.getResponseText()
		if (content != previous){
			println("NOTIFICATION $content, code: ${response.getCode().value}")
			response.advanced().setCanceled(true)
			if (content == "EXPLORE"){
				actor.scope.launch { MsgUtil.sendMsg("explore", "explore($content)", actor) }
			} else if (content == "SUSPEND") {
				actor.scope.launch { MsgUtil.sendMsg("suspend", "suspend($content)", actor) }
			} else if (content == "TERMINATE") {
				actor.scope.launch { MsgUtil.sendMsg("terminate", "terminate($content)", actor) }
			} 
			previous = content
		} else {
			println("Same as before, no send")
		}
	}
}
</pre>
</td>
</tr>
</tbody></table> 

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>Robot command resource. (Maicol)</h4>
<pre>
class resRobotCommand(name : String) : CoapResource( name ){
	var state  = State.HOME
	
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		//println("resource $name  | GET: ${exchange.getRequestText()} pos=$pos moving=$moving" )
		exchange.respond( "$state" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val prevState = state
		val msg = exchange.getRequestText()
		//println("resource $name  | PUT: $msg")
		when( msg ){
			"explore" 	->  { state = State.EXPLORE }
			"suspend" 	-> 	{ state = State.SUSPEND }
			"terminate" ->	{ state = State.TERMINATE }
			"home"		->  { state = State.HOME }
			"waiting" -> { state = State.WAITING}
 			//else -> println("")
		}
		changed()	// notify all CoAp observers

		println("put: $msg")
 		exchange.respond(CHANGED)
	}
</pre>
</td>
</tr>
</tbody></table> 

 	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;font-size:small;color:white">
By studentName email: student@studio.unibo.it  
<img src="./img/emiglio.png" alt="mbot" width="8%" height="8%">
</div> 
</body>
</html>