<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <!--
<link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
<script type="text/javascript" src="../css/issStyle.js"></script>
-->
<style type="text/css">
<!--
body
{
    margin-left:  30px;
    margin-right: 30px;
};

P
{
    font-family: Tahoma;
    font-size: 10pt;
};

a, a:visited, a:active, a:link, a:hover {
    text-decoration: underline;
    color: #545454;
    background-color: transparent;
}

a:hover {
    background-color: #cccccc;
}


hr {
    clear: both;
    height: 1px;
    color: #242424;
    background-color: transparent;
}

h1, h2, h3, h4 {
    color: #242424;
    clear: left;
    font: 100% Tahoma, Helvetica, Arial, sans-serif;
    margin: 10;
    margin-right: 15px;
    margin-bottom: 0.5em;
    padding-top: 0.5em;
    border-bottom: 1px solid #242424;
}

h1 {
    font-size: 150%;
    background-color: #b2c0ff;
}

h2 {
    background-color: #d9fbff;
    font-size: 130%;
}

h3 {
	background-color: #e6ccff;
    font-size: 120%;
}
h4 {
    background-color: #99ffcc;
    font-size: 90%;
}
#i {
    color: #ff1010;
}
tt{
	font-family: "Arial";
    font-size: 80%;
	color: #006600;
}
em{
	font-family: "Arial";
    font-size: 80%;
	font-weight: bold;
	border-style:solid;
	border-color: #ccffff;
    color: #0033cc;
}
bc{
	font-family: "Arial";
	font-size: 80%;
	font-weight: bold;
    color: #990000;
	background-color: #fcf8c7;
}
k{
	font-family: "Arial";
	font-weight: bold;
    color: #990000;
	 
}
ks{
	font-family: "Arial";
	font-weight: bold;
    color: #0000CD	;
	 
}
kc{
	font-family: "Arial";
	font-weight: bold;
    color: #008000	;
	 
}
pre{
	font-family: "Helvetica";
	font-size: 60%;
	background-color: #fcf8c7;
	border: 1px solid blue;
}
m{
	font-family: "Helvetica";
	line-height: 100%;
 	font-size: 75%;
}
div.body{
    font-size: 18px;
}    
div.req{
	background-color: #d9ffb3;
    font-size: 18px;
	width: 700px;
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}       
div.remark{
	background-color: #FFFC33;     
    border: 3px solid green;
    padding: 15px;
    margin: 10px;
}  
table, th, td {
  border: 1px solid black;
  border-collapse: collapse;
}         
    
  -->
</style>
    
<head>
   
<title>FinalTask-ISS-2020</title></head>
    
<body>
<div id="top">
<h1>FinalTask-ISS-2020<font size="5"></font> </h1>
</div>  

<div class="body"> 
<h2>Introduction</h2>
The <em>supervisor</em> of a waiting room (<em>wroom</em>) of a large train station intends to promote automatic collection of the rubbish, by means of ddr robots.
To this end, some specialized robot (<em>detector</em>) periodically explores the surface of the <em>wroom</em> in order to collect objects 
made of recyclable material, in particular bottles made of <i>plastic</i> .
 
<h2>Requirements</h2>
<div class="req">
Design and build the software to put on board of the <em>plasticBox</em> and of the <em>detector</em>. The system
must be able to accept the following commands sent by the <i>smart-phone</i> of the <em>supervisor</em>:

<ul>
<li><bc>explore</bc>: the <em>detector</em> must execute the task <i>Explore the room</i>.</li>
<!-- <li><em>empty</em>:   the <em>detector</em> must execute in autonomous way  the <i>Empty the detectorBox</i> task.</li> -->
<li><bc>suspend</bc>:   the <em>detector</em> must execute the task <i>Go to home</i>. </li>
<li><bc>terminate</bc>:  the <em>detector</em> must execute the task <i>Terminate the work</i>.</li>

</ul>
</div>

<h2>Requirement analysis</h2>

<h3>Functional TestPlan</h3>
<h4>Explore</h4>
After discussing with the client, the objective of this test plan is to verify that the detector is able to explore the entirety of the room, as a consequence, the entire map of the room.<br/>
<ul>
<li>At the start of the test the detector is situated in the top-left corner of the room.</li>
<li>At the end of the test the detector must have went through every cell of the map.</li>
</ul>

<h2>Problem analysis</h2>

<h3>The wroom problematics</h3>
<h4>The planner</h4>
The softwarehouse is already provided of a tool called planner.<br/>
This tool is able to produce a map and to make plans on it.<br/>
Every time the robot makes a move, the plan is calculated and the map is produced with every step.<br/>
If the robot encounters an obstacle, the map must be updated with the obstacle position and the plan must be recalculated.


<h4>The map</h4>
The map produced its based on the robot measure: every robot step its a new cell on the map, this cell is filled with a 1,0 or X depending on the situation.<br/>
If the robot has explored the cell the map shows a 1, otherwise a 0 if its not yet explored or an X if its an obstacle.<br/>
This process of mapping could be automatized if the room and the objects in it are static, otherwise the process must be executed every time the detector explores the room.
<h4>The room problematic final take</h4>
Having at disposal this tool, it doesn't matter if the room has objects or not, or if they are moving or not, the map can be calculated every time the robot explores it.

<h4>The movement problematic</h4>
The robot can move forward, backward and can turn left or right by 90 degrees, morover the robot exploration always start with the robot in coordinates (0,0) facing south.
<h4>The obstacle problematic</h4>
The robot is able to move, as a consequence, a new problematic arise: the robot, when moving forward, should be able to stop in the presence of an obstacle.<br/>
The stop should be forced below a certain threshold distance from the obstacle.<br/>
This is already possible and already implemented inside the basicrobot.qak.<br/>
When using a real robot a sensor is needed to notify the basicrobot of an obstacle.<br/>
This was already discussed in the basicrobot development, refer to it for more informations.

<h3>The plastic box problematic (Maicol)</h3>
How is the plasticBox supposed to know how many bottles has collected at a given time?<br/>
Considering that the content of the detectorBox is released inside the plasticBox, this problematic could be solved in different ways:<br/>
<ul>
	<li>The plasticBox is equipped with a sensor that allows to count the number of bottles that are being discharged, in this case the detector just check the resource to see if he can discharge.</li>
	<li>The plasticBox interacts directly with the detector and its notified of the number of bottles that the detector is discharging.</li>
	<li>The plasticBox and the detector interacts only via CoAP updating resources.</li>
</ul>
As an analyst, the choice that better solves our case, is that the detector, after checking that 
the plasticBox can receive the content of the detectorBox, notifies the plasticBox of the bottles that it is discharging.<br/>
This check is possible via the CoAP resources updated by the plasticBox and the detectorBox.<br/>
This choice was taken because the company doesn't possess a sensor that allows to count bottles, and the client is cheap.

<h3>Finding the plastic box problematic</h3>
When the detector has to empty the detectorBox, it could happen that the plasticBox hasn't already been discovered.<br/>
To prevent this kind of situation, it is assumed that the plasticBox is always situated in a known place of the room.<br/>
In particular is situated at coordinates (0,0).

<h3>Functional Architecture</h3>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The Detector (Christian/Bondi)</h4>
<pre>

</pre>
</td>
<td>
<h4>Steprobot (Christian)</h4>
<pre>

</pre>
</td>
</tr>
</tbody></table>


<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The plasticBox (Maicol)</h4>
<pre>
QActor plasticbox context ctxWroom{
["
	var Result:HashMap<Int,Int> = HashMap<Int,Int>()
	var NPB:Int = 0
"]
	State s0 initial{
		run kotlincode.coapSupport.init("coap://localhost:5683")  //TO CHANGE!!!
		["NPB = plasticBox.plasticBoxSupport.NPB"]
		run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "NPB=$NPB")
		run kotlincode.coapSupport.readPlasticBox("wroom/plasticBox", Result)
		["val Bottles = Result.get(1)
		  val npb = Result.get(2)"]
	}
	Goto work
	
	State work {}
	Transition t0
		whenMsg collect -> doCollect
		whenMsg empty -> emptyTheBox
	
	State doCollect{
		onMsg(collect : collect(X)) {
			["var Bottles = payloadArg(0)"]
			run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "$Bottles")
		}
	}
	Goto work

	State emptyTheBox {
		onMsg(empty : empty(X)) {
			["var Bottles = payloadArg(0)"]
			run kotlincode.coapSupport.updateResource(myself, "wroom/plasticBox", "0")
		}
	}
	Goto work
}
</pre>
</td>
<td>
<h4>The resource of the plasticBox (Maicol)</h4>
<pre>
class resPlasticBox( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var bottles = 0
	var NPB = 0 
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$bottles,$NPB" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetBottles() }
	 		else -> {
				if (msg.contains("NPB")) {
					val NPBValue = msg.substring(4)
					setNPB(NPBValue)
				} else {
					updateBottles(msg)
				}
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun updateBottles(msg:String){
		var value = msg.toIntOrNull()
		if (value != null) {
			bottles = bottles+value
		}
	}
	fun resetBottles(){
		bottles = 0
	}
	fun setNPB(NPBValue:String){
		var value = NPBValue.toIntOrNull()
		if (value != null){
			NPB = value
		}
	}
}
</pre>
</td>
</tr>
</tbody></table>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The detectorBox (Maicol)</h4>
<pre>
QActor detectorbox context ctxWroom{
["
	var Result:HashMap<Int,Int> = HashMap<Int,Int>()
	var NDB:Int = 0
"]
 	State s0 initial{
 		run kotlincode.coapSupport.init("coap://localhost:5683")
 		["NDB = detector.detectorSupport.NDB"]
 		run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "NDB=$NDB")
 		run kotlincode.coapSupport.readDetectorBox("wroom/detectorBox", Result)
		["val Bottles = Result.get(1)
		  val ndb = Result.get(2)"]
 	}
	Goto work 
	
	State work{}
	Transition t0
		whenMsg updateBottle -> updateBottleResource
		whenMsg emptyBottleResource -> emptyBottleResource
	
  	State updateBottleResource{
		onMsg( updateBottle : updateBottle(X)){
			run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "1")
		}   
	}
  	Goto work 
	
	State emptyBottleResource {
		onMsg(emptyBottleResource : emptyBottleResource(X)){
			run kotlincode.coapSupport.updateResource(myself, "wroom/detectorBox", "0")
		}
	}
	Goto work
 }
</pre>
</td>
<td>
<h4>The resource of the detectorBox (Maicol)</h4>
<pre>
class resDetectorBox( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var bottles = 0
	var NDB = 0
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$bottles, $NDB" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetBottles() }
	 		else -> {
				if (msg.contains("NDB")) {
					val NDBValue = msg.substring(4)
					setNDB(NDBValue)
				} else {
					updateBottles()
				}
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun updateBottles(){
		bottles = bottles+1
	}
	fun resetBottles(){
		bottles = 0
	}
	fun setNDB(NDBValue:String){
		var value = NDBValue.toIntOrNull()
		if (value != null){
			NDB = value
		}
	}
}
</pre>
</td>
</tr>
</tbody></table>

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>ResDetectorPosition (Maicol)</h4>
<pre>
class resDetectorPosition( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var pos        = "(0,0)"
	var direction  = "SUD"
	var moving     = "idle"
	init{
		setObservable(true)		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "pos$pos,dir($direction),moving$moving" )  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" -> resetDetector()
 			else -> {
				var splitted = msg.split(".")
				pos = splitted[0]
				direction = splitted[1]
				moving = splitted[2]
			}
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun resetDetector(){
		pos = "(0,0)"
		direction = "SUD"
		moving = "false"
	}
}
</pre>
</td>
<td>
<h4>ResRoomMap (Maicol)</h4>
<pre>
class resRoomMap( val owner: ActorBasic, name : String) : CoapResource( name ){
 	var roomMap:String = ""
	init{
		setObservable(true)
		println("resource $name  | created  " );		
	}
	override fun handleGET( exchange : CoapExchange ) {
		exchange.respond( "$roomMap ")  // moving=$moving" , $pos dir($direction)
	}
	override fun handlePUT( exchange : CoapExchange) {
		val msg = exchange.getRequestText()
		when( msg ){
			"0" ->  { resetMap() }
	 		else -> {
				roomMap = msg
	 		} 
		}
		changed()	// notify all CoAp observers
 		exchange.respond(CHANGED)
	}
	fun resetMap(){
		roomMap = ""
	}
}
</pre>
</td>
</tr>
</tbody></table>


<h3>The ProductBacklog</h3>
<strong>TASK EXPLORE THE ROOM</strong>: implement this task.<br/>
<strong>TASK EMPTY THE DETECTORBOX</strong>: implement this task.<br/>
<strong>PLASTICBOX</strong>: implement the plasticBox qactor.<br/>
<strong>FRONTEND</strong>: add 2 new buttons for suspend and terminate.<br/>
<strong>TASK GO TO HOME</strong>: implement this task.<br/>
<strong>TASK TERMINATE THE WORK</strong>: implement this task.<br/>
<strong>RESOURCES</strong>: implement the new resources. <br/>
<strong>TESTPLANS</strong>: prepare functional test plans.<br/>

<h3>The Effort/Resources</h3>
<strong>PLASTICBOX</strong>: The implementations of the plasticBox requires a .QAK and a resource. (1 hour)<br/>
<strong>FRONTEND</strong>: Add 2 buttons. (5 minute)<br/>
<strong>RESOURCES</strong>: Estimated 1 man hour.<br/>
<strong>DETECTOR WITH TASKS</strong>: Estimated 1 week because it comprehends the planner development.<br/>
<strong>TESTPLANS</strong>: Estimated 3 man hour.

<h2>Test plans</h2> 
<div class="remark">
<ks>GOAL</ks>: give a formal description (for example, by using <ks>JUnit</ks>) of the <k>functional TestPlans</k>, with reference to the <k>logical architecture</k> of the system .
</div>

<h2>Project</h2> 
<h3>Magic Numbers and the need of new adapters (Maicol)</h3>
The detectorBox needs a constant value to be started: NDB.<br/>
The plasticBox needs a constant value to be started: NPB.<br/>
These values are related to the capacity of the bins that these actors represent.<br/>
The problem is that if the bin is changed to another one, the main code must be modified to set the correct values.<br/>
This is not an appropriate behaviour, as a consequence, a new adapter is created for each Box.<br/>
The job of the adapters is to read a configuration file that contains all the info that are required to initialize the actors and create a support that store these informations.<br/>
This change will also be relevant for future upgrades if more informations are needed to be configured.<br/><br/>
<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The detectorAdapter (Maicol)</h4>
<pre>
class detectorAdapter( name : String ) : ActorBasic( name ){  
    init{
		println("	--- detectorAdapter | started")
		val sol1 = pengine.solve( "consult('detectorConfig.pl')." )
		if( ! sol1.isSuccess() ){
			println("	--- detectorAdapter | ERROR in detectorConfig.pl")
		}else{
	 		val sol2 = pengine.solve( "detectorBox(NDB)." )
	 		if( sol2.isSuccess() ){
				val NDB =  sol2.getVarValue("NDB").toString()
				println("	--- detectorAdapter | USING NDB: $NDB")
				val NDB_Int = NDB.toInt()
				detector.detectorSupport.create( NDB_Int )   
			}
		}		  		      
    }
    override suspend fun actorBody(msg : ApplMessage){
        //println("	--- robotAdapterQaStream | received  msg= $msg "  ) //msg.msgContent()=cmd(X)
		sysUtil.traceprintln(" $tt $name | received  $msg "  ) //msg.msgContent()=cmd(X)
    }
}
</pre>
</td>
<td>
<h4>The detectorSupport (Maicol)</h4>
<pre>
object detectorSupport{
	var NDB  :  Int = 0
	
	fun create( ndb:Int ){
		NDB = ndb
	}
}
</pre>
</td>
</tr>
</tbody></table> 

<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The plasticBoxAdapter (Maicol)</h4>
<pre>
class plasticBoxAdapter( name : String ) : ActorBasic( name ){  
    init{
		println("	--- plasticBoxAdapter | started")
		val sol1 = pengine.solve( "consult('plasticBoxConfig.pl')." )
		if( ! sol1.isSuccess() ){
			println("	--- plasticBoxAdapter | ERROR in plasticBoxConfig.pl")
		}else{
	 		val sol2 = pengine.solve( "plasticBox(NPB)." )
	 		if( sol2.isSuccess() ){
				val NPB =  sol2.getVarValue("NPB").toString()
				println("	--- plasticBoxAdapter | USING NPB: $NPB")
				val NPB_Int = NPB.toInt()
				plasticBox.plasticBoxSupport.create( NPB_Int )   
			}
		}		  		      
    }
 
    override suspend fun actorBody(msg : ApplMessage){
        //println("	--- robotAdapterQaStream | received  msg= $msg "  ) //msg.msgContent()=cmd(X)
		sysUtil.traceprintln(" $tt $name | received  $msg "  ) //msg.msgContent()=cmd(X)
    }
}
</pre>
</td>
<td>
<h4>The plasticBoxSupport (Maicol)</h4>
<pre>
object plasticBoxSupport{
	var NPB  :  Int = 0
	
	fun create( npb:Int ){
		NPB = npb
	}
}
</pre>
</td>
</tr>
</tbody></table> 
<h3>From MQTT to CoAP (Christian)</h3>
To exclude any knowledge of the implementation detail to the front-end, the front-end will send the required command to the detector via CoAP resource instead of mqtt.
<table style="width:50%" border="1">
<tbody>
<tr>
<td style="width:50%">
<h4>The Detector as a resource observer. (Christian)</h4>
<pre>
run kotlincode.coapSupport.observeCommands(myself)
</pre>
</td>
<td>
<h4>The resource observer (Christian)</h4>
<pre>
fun observeCommands(actor: ActorBasic) {
		setClientForPath("wroom/robotCommand")
		val relation = client.observe(ForwardCommandToActor(actor))
}

class ForwardCommandToActor(actor: ActorBasic): CoapHandler {
	
	var actor: ActorBasic
	var previous: String? = null
	init {
		this.actor = actor
	}
	override fun onLoad(response: CoapResponse) {
		val content = response.getResponseText()
		if (content != previous){
			println("NOTIFICATION $content, code: ${response.getCode().value}")
			response.advanced().setCanceled(true)
			if (content == "EXPLORE"){
				actor.scope.launch { MsgUtil.sendMsg("explore", "explore($content)", actor) }
			} else if (content == "SUSPEND") {
				actor.scope.launch { MsgUtil.sendMsg("suspend", "suspend($content)", actor) }
			} else if (content == "TERMINATE") {
				actor.scope.launch { MsgUtil.sendMsg("terminate", "terminate($content)", actor) }
			} 
			previous = content
		} else {
			println("Same as before, no send")
		}
	}
}
</pre>
</td>
</tr>
</tbody></table> 


<h2>Testing</h2> 
<div class="remark">
<ks>GOAL</ks>: complete the <k>functional TestPlans</k> according to the project code and execute them.
</div>


<table style="width:100%" border="1">
<tr>
<td style="width:50%">
</td>
<td></td>
</tr>
</table>
	      	
<br/><br/> 	
</div>  

<div style="background-color:rgba(86, 56, 253, 0.9); width:60%;text-align:left;font-size:small;color:white">
By studentName email: student@studio.unibo.it  
<img src="./img/emiglio.png" alt="mbot" width="8%" height="8%">
</div> 
</body>
</html>