{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "slideshow": {
     "slide_type": "subslide"
    }
   },
   "source": [
    "# Using the basicrobot \n",
    "See the project it.unibo.basicrobot2020"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Interaction with the Virtual Robot\n",
    "The virtual robot is described in \n",
    "<a href=\"http://htmlpreview.github.com/?https://github.com/anatali/iss2020Lab/blob/master/it.unibo.robot2020/userDocs/LabVirtualRobot.html\" target=\"web\">\n",
    "LabVirtualRobot</a>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##############################################################\n",
    "# clientToWenv.py\n",
    "# sendToVirtualRobot : sends a command in output\n",
    "# read               : acquires data from input\n",
    "##############################################################\n",
    "import socket\n",
    "import time\n",
    "import json\n",
    "\n",
    "sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
    "virtualRobotPort = 8999\n",
    "sep = ';'   #required by the Soffritti virtual robot 'language'\n",
    "\n",
    "goForwardMsg  = '{\"type\": \"moveForward\",   \"arg\": -1  }'\n",
    "goBackwardMsg = '{\"type\": \"moveBackward\",  \"arg\": -1  }'\n",
    "turnLeftMsg   = '{\"type\": \"turnLeft\",      \"arg\": 400 }'\n",
    "turnRightMsg  = '{\"type\": \"turnRight\",     \"arg\": 400 }'\n",
    "haltMsg       = '{\"type\": \"alarm\",         \"arg\": 0   }'\n",
    "\n",
    "def connect(port) :\n",
    "    server_address = ('localhost', port)\n",
    "    sock.connect(server_address)    \n",
    "    print(\"CONNECTED WITH the virtual robot\" , server_address)\n",
    "\n",
    "def sendToVirtualRobot( message ) :\n",
    "    print(\"forward \", message)\n",
    "    msgJson = json.loads( message )\n",
    "    msg     = sep+ json.dumps(msgJson)+ sep \n",
    "    byt=msg.encode()    #required in Python3\n",
    "    sock.send( byt )\n",
    "\n",
    "def work() :\n",
    "    sendToVirtualRobot( goForwardMsg ) \n",
    "    time.sleep(1)\n",
    "    sendToVirtualRobot( haltMsg ) \n",
    "\n",
    "def read() :\n",
    "    BUFFER_SIZE = 1024\n",
    "    data = sock.recv(BUFFER_SIZE)\n",
    "    print( \"received data:\", data )\n",
    "\n",
    "def terminate() :\n",
    "    sock.close()\n",
    "    print(\"BYE\")\n",
    "\n",
    "###########################################    \n",
    "connect(virtualRobotPort)\n",
    "work()\n",
    "read()\n",
    "terminate()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Interaction with the basicrobot qactor\n",
    "See the model: <a href=\"../src/basicrobot.qak\" target=\"code\">basicrobot.qak</a>.\n",
    "<ol>\n",
    "    <li>\n",
    "        Activate the virtual robot and oper a browser on <tt>localhost:8090</tt>\n",
    "    </li>\n",
    "    <li>Launch the <tt>basicrobot</tt> as a 'standalone' application (microservice)\n",
    "<pre>\n",
    "cd C:\\..\\it.unibo.basicrobot2020-1.0\\bin\n",
    "it.unibo.basicrobot2020.bat\n",
    "</pre>\n",
    "    </li>\n",
    "    <li>\n",
    "        Execute the python code hereunder to move the robot\n",
    "    </li>\n",
    "    <li>\n",
    "        Look at the received data when the (virtual) robot hits an obstacle\n",
    "    </li>\n",
    "</ol>\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "##############################################################\n",
    "# sendDispatch       : sends a command in output\n",
    "# read               : acquires data from input\n",
    "##############################################################\n",
    "import socket\n",
    "import time\n",
    "\n",
    "robotName      = \"basicrobot\" # robotadapter | basicrobot\n",
    "\n",
    "hostAdress     = '192.168.1.15'\n",
    "basicRobotPort = 8018  \n",
    "smartRobotPort = 8020  \n",
    "\n",
    "goForwardMsg  = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(w),1)\"\n",
    "goBackwardMsg = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(s),1)\" \n",
    "turnLeftMsg   = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(a),1)\"  \n",
    "turnRightMsg  = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(d),1)\"  \n",
    "haltMsg       = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(h),1)\"\n",
    "\n",
    "sock          = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
    "\n",
    "def connect(port) :\n",
    "    server_address = (hostAdress, port)\n",
    "    sock.connect(server_address)    \n",
    "    print(\"CONNECTED WITH , server_address\")\n",
    "\n",
    "def sendDispatch( message ) :\n",
    "    print(\"forward \", message)\n",
    "    msg = message + \"\\n\"\n",
    "    byt=msg.encode()    #required in Python3\n",
    "    sock.send(byt)\n",
    "\n",
    "def terminate() :\n",
    "    sock.close()    #qak infrastr receives a msg null\n",
    "    print(\"BYE\")\n",
    "\n",
    "def read() :\n",
    "    sock.settimeout(1)\n",
    "    try:\n",
    "        rec = sock.recv(1024) # try to receive 100 bytes\n",
    "        print(\"RECEIVED:\" , rec )\n",
    "    except socket.timeout: # fail after 1 second of no activity\n",
    "        print(\"Didn't receive data! \")\n",
    "    finally:\n",
    "        terminate()\n",
    "\n",
    "def console() :  \n",
    "    cmd = str(input())\n",
    "    while( cmd != \"z\" ) :\n",
    "        if( cmd == \"w\" ) :\n",
    "            sendDispatch( goForwardMsg ) \n",
    "        if( cmd == \"s\" ) :\n",
    "            sendDispatch( goBackwardMsg ) \n",
    "        if( cmd == \"a\" ) :\n",
    "            sendDispatch( turnLeftMsg ) \n",
    "        if( cmd == \"d\" ) :\n",
    "            sendDispatch( turnRightMsg ) \n",
    "        if( cmd == \"h\" ) :\n",
    "            sendDispatch( haltMsg ) \n",
    "        cmd = str(input())\n",
    "          \n",
    "##################################################\n",
    "connect(basicRobotPort)\n",
    "console()\n",
    "read() "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Coroutines in Python work in a very similar way to Generators. \n",
    "Generators produce data\n",
    "Coroutines consume data"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#===========================================================\n",
    "#Generators produce values\n",
    "#===========================================================\n",
    "\n",
    "def cdown(n):\n",
    "    print( \"cdown from\", n)\n",
    "    while n > 0:\n",
    "        yield n\n",
    "        n -=1\n",
    "#When the generator returns, iteration stops\n",
    "x = cdown(2)   \n",
    "x\n",
    "next(x)    #python 3.x  --> 2\n",
    "next(x)    # --> 1\n",
    "#next(x) #ERROR: \n",
    "#x.next()  #NO in python 3.x\n",
    "#for i in cdown(5):\n",
    "#    print( i )\n",
    "\n",
    "#One of the most powerful applications of generators is setting up processing pipelines"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#===========================================================\n",
    "# Coroutines tend to consume values\n",
    "#===========================================================\n",
    "\n",
    "def grep(pattern):\n",
    "    n = 0\n",
    "    print( \"Looking for %s\" % pattern)\n",
    "    try:\n",
    "        while True:\n",
    "            #use yield as an expression\n",
    "            #If you use yield more generally, you get a coroutine\n",
    "            # functions can consume values sent to it\n",
    "            line = yield   #Sent values are returned by yield\n",
    "            n = n+1\n",
    "            if pattern in line:\n",
    "                print( line , \"| lines=\", n)\n",
    "    except GeneratorExit:\n",
    "        print( \"grep Going away. Goodbye\" )\n",
    "\n",
    "g = grep(\"python\")\n",
    "#next(g)     #you can use also\n",
    "g.send(None) # advances execution\n",
    "g.send(\"hello 1\")\n",
    "g.send(\"hello 2\")\n",
    "g.send(\"hello 3 python\")\n",
    "g.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "STARTING ... \n",
      "CONNECTED WITH  ('192.168.1.15', 8018)\n"
     ]
    },
    {
     "data": {
      "text/plain": [
       "<Task pending coro=<work() running at <ipython-input-15-c519603567e8>:102>>"
      ]
     },
     "execution_count": 15,
     "metadata": {},
     "output_type": "execute_result"
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "work STARTS :\n",
      "readSock  STARTS :\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1127)\n",
      "\n",
      "sonarData= ['30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1128)\n",
      "\n",
      "sonarData= ['30', '30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1129)\n",
      "\n",
      "sonarData= ['30', '30', '30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1130)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1131)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30', '30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(31),1132)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30', '30', '31']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(30),1133)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30', '30', '31', '30']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(31),1134)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30', '30', '31', '30', '31']\n",
      "RECEIVED: msg(sonarRobot,event,robotadapter,none,sonar(31),1135)\n",
      "\n",
      "sonarData= ['30', '30', '30', '30', '30', '31', '30', '31', '31']\n",
      "work END :\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    }
   ],
   "source": [
    "##############################################################\n",
    "# sendDispatch       : sends a command in output\n",
    "# read               : acquires data from input\n",
    "##############################################################\n",
    "import socket\n",
    "import time\n",
    "import matplotlib.pyplot as plt\n",
    "import asyncio\n",
    "\n",
    "robotName      = \"basicrobot\" # robotadapter | basicrobot\n",
    "\n",
    "hostAdress     = '192.168.1.15'\n",
    "basicRobotPort = 8018  \n",
    "smartRobotPort = 8020  \n",
    "\n",
    "sonarData      = []\n",
    "\n",
    "goForwardMsg  = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(w),1)\"\n",
    "goBackwardMsg = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(s),1)\" \n",
    "turnLeftMsg   = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(a),1)\"  \n",
    "turnRightMsg  = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(d),1)\"  \n",
    "haltMsg       = \"msg(cmd,dispatch,python,\"+ robotName +\",cmd(h),1)\"\n",
    "\n",
    "sock          = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n",
    "\n",
    "def connect(port) :\n",
    "    server_address = (hostAdress, port)\n",
    "    sock.connect(server_address)    \n",
    "    print(\"CONNECTED WITH \", server_address)\n",
    "\n",
    "def terminate() :\n",
    "    sock.close()    #qak infrastr receives a msg null\n",
    "    print(\"BYE\")\n",
    "\n",
    "#reader  = None\n",
    "    \n",
    "async def plot() :\n",
    "    print(\"plot STARTS ...\")\n",
    "    for i in range(1,10):\n",
    "        #data = yield\n",
    "        print(\"PLOT DATA:\" , sonarData )\n",
    "        plt.plot( list(sonarData), color='red')\n",
    "        await asyncio.sleep(1) \n",
    "'''        \n",
    "        #plt.plot(list(sonarData), color='red')\n",
    "#        if not reader is None :\n",
    "#            reader.send( 1 )\n",
    "#        else :\n",
    "#            reader = read( )\n",
    "#            print(\"PLOT wait:\" , data )\n",
    "'''        \n",
    "\n",
    "#plotter = plot()\n",
    "#next( plotter )\n",
    "\n",
    "async def readSock() :\n",
    "    print(\"readSock  STARTS :\"   )\n",
    "    for i in range(1,10):\n",
    "        try:\n",
    "            line = \"\"\n",
    "            while not line.endswith('\\n'):\n",
    "                data = sock.recv(1024) # try to receive k bytes\n",
    "                line = line + data.decode(\"utf-8\") \n",
    "            print(\"RECEIVED:\" , line )\n",
    "            msgitems = line.split(\",\")\n",
    "            v = msgitems[4].split('(')[1].split(')')[0]\n",
    "            sonarData.append( v )\n",
    "            print(\"sonarData=\" , sonarData )\n",
    "        except socket.timeout: # fail after 1 second of no activity\n",
    "            print(\"Didn't receive data! \")\n",
    "\n",
    "async def read() :\n",
    "    '''   \n",
    "    sock.settimeout(60000)\n",
    "    print(\"read STARTS :\"   )\n",
    "    ''' \n",
    "    #for i in range(1,10):\n",
    "    print(\"read STARTS :\"   )\n",
    "    try:\n",
    "        line = \"\"\n",
    "        while not line.endswith('\\n'):\n",
    "            data = sock.recv(1024) # try to receive k bytes\n",
    "            line = line + data.decode(\"utf-8\") \n",
    "        print(\"RECEIVED:\" , line )\n",
    "        msgitems = line.split(\",\")\n",
    "        v = msgitems[4].split('(')[1].split(')')[0]\n",
    "        sonarData.append( v )\n",
    "        print(\"sonarData=\" , sonarData )\n",
    "            #await asyncio.sleep(1)\n",
    "            #print(\"v=\" , v )\n",
    "            #plotter.send( v )\n",
    "            #goon = yield \n",
    "            ##yield line\n",
    "    except socket.timeout: # fail after 1 second of no activity\n",
    "        print(\"Didn't receive data! \")\n",
    "        #finally:\n",
    "            #terminate()\n",
    "    \n",
    "    #plt.plot( list(sonarData), color='red')\n",
    "reader = readSock()\n",
    "\n",
    "async def work() :\n",
    "    sock.settimeout(60000)\n",
    "    print(\"work STARTS :\"   )\n",
    "    #for i in range(5):\n",
    "        #asyncio.ensure_future( read() )\n",
    "    await reader\n",
    "        #print(\"work DONE :\"   )\n",
    "    #await asyncio.sleep(0.5)\n",
    "    print(\"work END :\"   )\n",
    "    plt.plot( list(sonarData), color='red')\n",
    "    plt.show()\n",
    "##################################################\n",
    "print(\"STARTING ... \")\n",
    "connect(basicRobotPort)\n",
    "\n",
    "loop = asyncio.get_event_loop()\n",
    "loop.create_task( work() )\n",
    "\n",
    "#loop.create_task( plot() )\n",
    "\n",
    "#myreader = read( )\n",
    "#next( myreader )\n",
    "#read( plotter )\n",
    "\n",
    "\n",
    "#next( sonarData )\n",
    "#console()\n",
    "#read() "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_introduction.htm\n",
    "GIL (Global Interpreter Lock): prevents multiple threads from executing Python code in parallel\n",
    "concurrency and parallelism are not same\n",
    "Queues are by default, thread-safe data structure and we need not worry about implementing complex locking mechanism. \n",
    "Asyncio module was added in Python 3.4 and it provides infrastructure for writing single-threaded concurrent code using co-routines.\n",
    "\n",
    "https://cheat.readthedocs.io/en/latest/python/asyncio.html"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import _thread\n",
    "import time\n",
    "\n",
    "def print_time( threadName, delay):\n",
    "   count = 0\n",
    "   while count < 5:\n",
    "      time.sleep(delay)\n",
    "      count += 1\n",
    "      print (\"%s: %s\" % ( threadName, time.ctime(time.time()) ))\n",
    "\n",
    "try:\n",
    "   _thread.start_new_thread( print_time, (\"Thread-1\", 2, ) )\n",
    "   _thread.start_new_thread( print_time, (\"Thread-2\", 4, ) )\n",
    "except:\n",
    "   print (\"Error: unable to start thread\")\n",
    "while 1:\n",
    "   pass"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "#The <threading> module implements in an object oriented way and treats every thread as an object.\n",
    "#Therefore, it provides much more powerful, high-level support for threads than \n",
    "#the <_thread> module. This module is included with Python 2.4.\n",
    "\n",
    "import threading\n",
    "import time\n",
    "exitFlag = 0\n",
    "\n",
    "class myThread (threading.Thread):\n",
    "   def __init__(self, threadID, name, counter):\n",
    "      threading.Thread.__init__(self)\n",
    "      self.threadID = threadID\n",
    "      self.name = name\n",
    "      self.counter = counter\n",
    "   def run(self):\n",
    "      print (\"Starting \" + self.name)\n",
    "      print_time(self.name, self.counter, 5)\n",
    "      print (\"Exiting \" + self.name)\n",
    "def print_time(threadName, delay, counter):\n",
    "   while counter:\n",
    "      if exitFlag:\n",
    "         threadName.exit()\n",
    "      time.sleep(delay)\n",
    "      print (\"%s: %s\" % (threadName, time.ctime(time.time())))\n",
    "      counter -= 1\n",
    "\n",
    "thread1 = myThread(1, \"Thread-1\", 1)\n",
    "thread2 = myThread(2, \"Thread-2\", 2)\n",
    "\n",
    "thread1.start()\n",
    "thread2.start()\n",
    "thread1.join()\n",
    "thread2.join()\n",
    "print (\"Exiting Main Thread\")\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio\n",
    "\n",
    "def hello_world(loop):\n",
    "   print('Hello World')\n",
    "   loop.stop()\n",
    "\n",
    "loop = asyncio.get_event_loop()\n",
    "\n",
    "loop.call_soon(hello_world, loop)\n",
    "\n",
    "loop.run_forever()\n",
    "loop.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio\n",
    "\n",
    "async def Myoperation():\n",
    "    print(\"First Coroutine\")\n",
    "    #asyncio.sleep(1)\n",
    "    \n",
    "loop = asyncio.get_event_loop()\n",
    "'''\n",
    "# you cannot invoke a run_until_complete(), \n",
    "# since the loop you will receive from asyncio.get_event_loop() will be active\n",
    "try:\n",
    "    loop.run_until_complete( Myoperation() )\n",
    "except Exception as e :\n",
    "    print(\"[ERROR] ->\" , e )\n",
    "\n",
    "#finally:\n",
    "   #loop.close()\n",
    "'''   \n",
    "# loop.create_task( Myoperation() )\n",
    "asyncio.run_coroutine_threadsafe( Myoperation(), loop )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio\n",
    "\n",
    "async def a():\n",
    "    for i in range(1,3):\n",
    "        print(\"Coroutine a\")\n",
    "        await asyncio.sleep(1) \n",
    "async def b():\n",
    "    for i in range(1,5):\n",
    "        print(\"Coroutine b\")\n",
    "        await asyncio.sleep(2) \n",
    "    \n",
    "loop = asyncio.get_event_loop()\n",
    "\n",
    "loop.create_task( a() )\n",
    "loop.create_task( b() )"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import asyncio\n",
    "import time\n",
    "\n",
    "async def Task_ex(n):\n",
    "    time.sleep(0.5)\n",
    "    print(\"Processing {}\".format(n))\n",
    "async def Generator_task():\n",
    "    for i in range(1):\n",
    "        asyncio.ensure_future( Task_ex(i) )\n",
    "    print(\"Tasks Completed\")\n",
    "    await asyncio.sleep(0.5)\n",
    "    print(\"Tasks Completed 1\")\n",
    "\n",
    "loop = asyncio.get_event_loop()\n",
    "loop.create_task( Generator_task() )\n",
    "#loop.run_until_complete(Generator_task())\n",
    "#loop.close()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os  #HAS NO ATTRIBUTE fork\n",
    "\n",
    "def child():\n",
    "    n = os.fork()\n",
    "   \n",
    "    if n > 0:\n",
    "        print(\"PID of Parent process is : \", os.getpid())\n",
    "\n",
    "    else:\n",
    "        print(\"PID of Child process is : \", os.getpid())\n",
    "child()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "BYE\n",
      "Myoperation START\n",
      "Myoperation END\n"
     ]
    }
   ],
   "source": [
    "import asyncio\n",
    "\n",
    "async def Myoperation(future):\n",
    "    print(\"Myoperation START\")\n",
    "    await asyncio.sleep(1)\n",
    "    print(\"Myoperation END\")\n",
    "    future.set_result('Future Completed')\n",
    "\n",
    "loop   = asyncio.get_event_loop()\n",
    "future = asyncio.Future()\n",
    "asyncio.ensure_future( Myoperation(future) )\n",
    "\n",
    "print(\"BYE\")\n",
    "#loop.create_task( Myoperation(future) )\n",
    "#print( future.result() )\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
